<?php/** CloneNjin** An MVC server-side PHP template cloning system.** MIT License** Copyright (c) 2016 Alexander Miles Fish** Permission is hereby granted, free of charge, to any person obtaining a copy* of this software and associated documentation files (the "Software"), to deal* in the Software without restriction, including without limitation the rights* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell* copies of the Software, and to permit persons to whom the Software is* furnished to do so, subject to the following conditions:** The above copyright notice and this permission notice shall be included in all* copies or substantial portions of the Software.** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE* SOFTWARE.*/
/*-----------------------------------------------------
* CloneNjin
*----------------------------------------------------* The core Template Engine
*----------------------------------------------------*/
class CloneNjin
{
	private $_registeredKeys = array();	/**
	*--------------------------------------------------------------
	* final public void registerKey(string $key, string|int $value)
	*--------------------------------------------------------------	* Registers and stores all keys needing to be parsed.	* New keys can be quickly added or removed. Registered 	* key overloading won't cause issues, so no need to use 	* each key in an alias. Any keys that exist in templates 	* or aliases must be registered or they will not be 	* parsed. If a key doesn't exist, the engine simply 	* continues parsing until it reaches the end of the file.	* 	* @param string $key	* @param string|int $value	* @return void 	*--------------------------------------------------------------*/
	final public function registerKey($key, $value) 
	{
		$this->_registeredKeys[$key] = $value;	}	/**	*-------------------------------------------------	* final public string parse(string $file)	*-------------------------------------------------	* The parse() method returns parsed source code 	* by adding to the clone creation. Call the parse() 	* method when registering a key that correspond to 	* a template or alias that either does or doesn't 	* need key parsing (header or footer key).	* IMPORTANT: Never parse anything located in 	* the public web root directory!	*	* @param string $file	* @return string	*-------------------------------------------------*/	final public function parse($file)	{			settype($file, "string");				if (!file_exists($file)) {			throw new Exception("CloneNjin Exception: Could not find '{$file}'.");		}				$sourceCode = file_get_contents($file);		foreach ($this->_registeredKeys as $key => $value) {			$sourceCode = str_replace('{{'.$key.'}}', $value, $sourceCode);		}				return $sourceCode;	}		/**	*----------------------------------------------	* final public void loadClone(void)	* ----------------------------------------------	* Resonsible for loading the clone.	* Invokes the parse method when all keys are 	* registered and outputs the full view. 	* 	* @param void	* @return void 	*----------------------------------------------*/	final public function loadClone()	{		echo $this->parse(VIEWS.DS.PAGE_PARENT.DS.PAGE.'.html');	}	} // End class CloneNjin